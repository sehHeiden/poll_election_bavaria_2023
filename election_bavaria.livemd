# Bavarian Election

```elixir
Mix.install(
  [
    {:explorer, "~> 0.6.1"},
    {:kino_vega_lite, "~> 0.1.7"},
    {:httpoison, "~> 1.8"},
    {:kino_bumblebee, "~> 0.3.0"},
    {:exla, "~> 0.5.1"},
    {:ecto_sqlite3, "~> 0.10"},
    {:kino_db, "~> 0.2.1"}
  ],
  config: [
    nx: [default_backend: EXLA.Backend]
  ]
)
```

## Polls

```elixir
alias VegaLite, as: Vl
```

```elixir
pools = Explorer.DataFrame.from_csv!("polls.csv")
```

```elixir
defmodule Graphs do
  def create_graph(data_source, title, party) do
    Vl.new(width: 500, height: 300, title: title)
    |> Vl.data_from_values(data_source, only: ["end_date", party, "institute"])
    |> Vl.layers([
      Vl.new()
      |> Vl.mark(:point)
      |> Vl.encode_field(:x, "end_date", type: :temporal, title: "poll end date")
      |> Vl.encode_field(:y, party, type: :quantitative, title: "percentage")
      |> Vl.encode_field(:color, "institute", type: :nominal),
      Vl.new()
      |> Vl.mark(:line, color: "firebrick", opacity: 0.5)
      |> Vl.transform(regression: party, on: "end_date")
      |> Vl.encode_field(:x, "end_date", type: :temporal, title: "poll end date")
      |> Vl.encode_field(:y, party, type: :quantitative, title: "percentage")
    ])
  end
end
```

```elixir
Graphs.create_graph(pools, "Polls - CSU", "csu")
```

```elixir
Graphs.create_graph(pools, "Pools - Buendnis-Gruene", "gruene")
```

```elixir
Graphs.create_graph(pools, "Pools - Freie Waehler", "fw")
```

```elixir
Graphs.create_graph(pools, "Pools - AFD", "afd")
```

```elixir
Graphs.create_graph(pools, "Pools - SPD", "spd")
```

```elixir
Graphs.create_graph(pools, "Pools - FDP", "fdp")
```

```elixir
VegaLite.new(width: 500, height: 300, title: "Linke - polls")
|> VegaLite.data_from_values(pools, only: ["end_date", "linke", "institute"])
|> VegaLite.layers([
  VegaLite.new()
  |> VegaLite.mark(:point)
  |> VegaLite.encode_field(:x, "end_date", type: :temporal, title: "poll end date")
  |> VegaLite.encode_field(:y, "linke", type: :quantitative, title: "percentage")
  |> VegaLite.encode_field(:color, "institute", type: :nominal),
  VegaLite.new()
  |> VegaLite.mark(:line, color: "firebrick", opacity: 0.5)
  |> VegaLite.transform(regression: "linke", on: "end_date")
  |> VegaLite.encode_field(:x, "end_date", type: :temporal, title: "poll end date")
  |> VegaLite.encode_field(:y, "linke", type: :quantitative, title: "percentage")
])
```

## Party

```elixir
parties_df =
  Explorer.DataFrame.new(
    party: ["csu", "fw", "spd", "gruene", "fdp", "afd", "linke"],
    candiate1: [
      "Markus Söder",
      "Hubert Aiwanger",
      "Florian von Brunn",
      "Ludwig Hartmann",
      "Martin Hagen",
      "Katrin Ebner-Steiner",
      "Adelheid Rupp"
    ],
    candidate2: [nil, nil, nil, "Katharina Schulze", nil, "Martin Böhm", nil]
  )

Explorer.DataFrame.table(parties_df)
```

## Fetch Mastodon Tags

Read mastodon toots/posts and save it into a database.

```elixir
topics =
  ~w[bayern bayernwahl bayernwahl2023 wahlen wahlkampf wahlumfrage wahlen23 wahlen2023 spd csu  gruene  grune gruenen grunen afd freiewaehler freiewahler fw fpd linke soeder soder aiwanger]
```

```elixir
defmodule Mastodon.RequestByTag do
  def query(tag) do
    response = HTTPoison.get!("https://chaos.social/api/v1/timelines/tag/#{tag}")
    Jason.decode!(response.body)
  end
end
```

```elixir
posts =
  topics
  |> Enum.map(fn q -> Mastodon.RequestByTag.query(q) end)
  |> List.flatten()
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
toot_data =
  Enum.map(posts, fn post ->
    %{
      user_name: post["account"]["acct"],
      id: post["id"],
      content: post["content"],
      date: post["created_at"],
      language: post["language"]
    }
  end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
user_data =
  Enum.map(posts, fn post ->
    %{
      user_name: post["account"]["acct"],
      followers: post["account"]["followers_count"],
      following: post["account"]["following_count"],
      avatar: post["account"]["avatar"],
      user_id: post["account"]["id"],
      note: post["account"]["note"]
    }
  end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
fields_data =
  Enum.map(posts, fn post ->
    fields = post["account"]["fields"]

    Enum.map(fields, fn field ->
      %{
        user_name: post["account"]["user"],
        field_name: field["name"],
        field_value: field["value"]
      }
    end)
  end)
  |> List.flatten()
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
tag_data =
  Enum.map(posts, fn post ->
    tags = post["tags"]

    Enum.map(tags, fn tag ->
      tootid = post["id"]

      %{
        "tootid" => tootid,
        "tag" => if(tag, do: tag["name"], else: nil)
      }
    end)
  end)
  |> List.flatten()
```

## Database setup

<!-- livebook:{"continue_on_error":true} -->

```elixir
config = %{
  type: :sqlite,
  database: "baviarian_election_2023_mastodon.sqlitedb"
}
```

<!-- livebook:{"attrs":{"database_path":"baviarian_election_2023_mastodon.sqlitedb","type":"sqlite","variable":"conn"},"chunks":null,"kind":"Elixir.KinoDB.ConnectionCell","livebook_object":"smart_cell"} -->

```elixir
opts = [database: "baviarian_election_2023_mastodon.sqlitedb"]
{:ok, conn} = Kino.start_child({Exqlite, opts})
```

```elixir
File.exists?(config[:database])
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule Mastodon.Repo do
  use Ecto.Repo,
    otp_app: :mastodon,
    adapter: Ecto.Adapters.SQLite3
end
```

```elixir
Mastodon.Repo.start_link()
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Mastodon.Repo.Migration.CreateToot do
  use Ecto.Migration

  def change do
    create table(:toot) do
      add(:user_name, :string, null: false)
      add(:toot_id, :string, null: false)
      add(:content, :string)
      add(:date, :date)
      add(:language, :string, default: "de")
    end

    create(unique_index(:toot, [:user_name, :toot_id]))
  end
end

defmodule Mastodon.Repo.Migration.CreateTag do
  use Ecto.Migration

  def change do
    create table(:tag) do
      add(:toot_id, :string, null: false)
      add(:tag, :string, null: false)
    end

    create(unique_index(:tag, [:toot_id, :tag]))
  end
end

defmodule Mastodon.Repo.Migration.CreateUser do
  use Ecto.Migration

  def change do
    create table(:user) do
      add(:user_name, :string, null: false)
      add(:followers, :integer)
      add(:following, :integer)
      add(:avatar, :string)
      add(:user_id, :string, null: false)
      add(:note, :string)
    end

    create(unique_index(:user_name, [:name]))
  end
end

defmodule Mastodon.Repo.Migration.CreateField do
  use Ecto.Migration

  def change do
    create table(:field) do
      add(:user_name, :string, null: false)
      add(:field_name, :string, null: false)
      add(:field_value, :string, null: false)
    end

    create(unique_index(:field, [:user_name, :field_name, :field_value]))
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Mastodon.Toot do
  use Ecto.Schema

  schema "toots" do
    field(:user_name, :string)
    field(:toot_id, :string)
    field(:content, :string)
    field(:date, :date)
    field(:language, :string, default: "de")

    has_many(:tags, Mastodon.Tag)
    has_one(:user, Mastodon.User)
  end
end

defmodule Mastodon.Tag do
  use Ecto.Schema

  schema "tags" do
    # field(:toot_id, :string)
    field(:tag, :string)
    belongs_to(:toot, Mastodon.Toot)
  end
end

defmodule Mastodon.User do
  use Ecto.Schema

  schema "users" do
    field(:user_name, :string)
    field(:followers, :integer)
    field(:following, :integer)
    field(:avatar, :string)
    field(:user_id, :string)
    field(:note, :string)

    has_many(:toots, Mastodon.Toot)
  end
end

defmodule Mastodon.Field do
  use Ecto.Schema

  schema "fields" do
    field(:user_name, :string)
    field(:field_name, :string)
    field(:value, :string)
    belongs_to(:toot, Mastodon.Toot)
  end
end
```

```elixir
toot1 = Enum.at(toot_data, 0)
```

```elixir
%Mastodon.Toot{}
|> Ecto.Changeset.cast(toot1, [:content, :date, :id, :language, :user_name])
|> Ecto.Changeset.validate_required([:id, :user_name])
|> Ecto.Changeset.unique_constraint(:user_name)
|> Mastodon.Repo.insert()
```

## Classification

<!-- livebook:{"attrs":{"compiler":"exla","sequence_length":100,"task_id":"text_classification","top_k":4,"variant_id":"roberta_bertweet_sentiment"},"chunks":[[0,351],[353,496]],"kind":"Elixir.KinoBumblebee.TaskCell","livebook_object":"smart_cell"} -->

```elixir
{:ok, model_info} = Bumblebee.load_model({:hf, "finiteautomata/bertweet-base-sentiment-analysis"})

{:ok, tokenizer} = Bumblebee.load_tokenizer({:hf, "vinai/bertweet-base"})

serving =
  Bumblebee.Text.text_classification(model_info, tokenizer,
    top_k: 4,
    compile: [batch_size: 1, sequence_length: 100],
    defn_options: [compiler: EXLA]
  )

text_input = Kino.Input.textarea("Text", default: "Cats are so cute")
form = Kino.Control.form([text: text_input], submit: "Run")
frame = Kino.Frame.new()

Kino.listen(form, fn %{data: %{text: text}} ->
  Kino.Frame.render(frame, Kino.Text.new("Running..."))
  output = Nx.Serving.run(serving, text)

  output.predictions
  |> Enum.map(&{&1.label, &1.score})
  |> Kino.Bumblebee.ScoredList.new()
  |> then(&Kino.Frame.render(frame, &1))
end)

Kino.Layout.grid([form, frame], boxed: true, gap: 16)
```
